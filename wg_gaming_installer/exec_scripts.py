from __future__ import annotations

from pathlib import Path
from typing import TextIO

from wg_gaming_installer.sqlite_scripts import (
    PeerConfig,
    ServerIFConfig,
    ServerWGConfig,
)


def create_wg_config(
    wg_conf_path: Path,
    wg_config: ServerWGConfig,
    peer_config: list[PeerConfig],
    start_script_path: Path,
    stop_script_path: Path,
) -> None:
    """
    Generate an empty WireGuard configuration file using WG config database.
    """
    print(f"Generating empty WireGuard configuration file at {wg_conf_path}...")

    if not wg_conf_path.parent.exists():
        wg_conf_path.parent.mkdir(parents=True, exist_ok=True)

    # Write WireGuard configuration file
    with open(wg_conf_path, 'w') as f:
        f.write("# WireGuard configuration file, generated by wg_gaming_installer\n\n")
        f.write("[Interface]\n")
        if wg_config.ipv6:
            f.write(f"Address = {str(wg_config.ipv4)}, {str(wg_config.ipv6)}\n")
        else:
            f.write(f"Address = {str(wg_config.ipv4)}\n")
        f.write(f"ListenPort = {wg_config.listen_port}\n")
        f.write(f"PrivateKey = {wg_config.private_key}\n\n")
        # Quote paths to be safe if they contain spaces/special chars
        f.write(f'PostUp = "{str(start_script_path)}"\n')
        f.write(f'PostDown = "{str(stop_script_path)}"\n')
        f.write("SaveConfig = false\n")
        f.write("\n")
        for peer in peer_config:
            f.write(f"[Peer] # {peer.name}\n")
            f.write(f"PublicKey = {peer.public_key}\n")
            f.write(f"PresharedKey = {peer.preshared_key}\n")
            if peer.ipv6:
                f.write(
                    f"AllowedIPs = {str(peer.ipv4.ip)}/32, {str(peer.ipv6.ip)}/128\n"
                )
            else:
                f.write(f"AllowedIPs = {str(peer.ipv4.ip)}/32\n")
            f.write("\n")

    # Set file permissions to 600
    wg_conf_path.chmod(0o600)


def create_start_script(
    has_ipv6: bool,
    shell_path: Path,
    start_script_path: Path,
    nftables_conf_path: Path,
) -> None:
    """
    Generate start script based on current database config.
    """
    if not start_script_path.parent.exists():
        raise RuntimeError(
            f"Configuration folder {start_script_path.parent}"
            f" for {start_script_path} does not exist."
        )
    print(f"Generating nftables start script at {start_script_path}...")

    # Write nftables start configuration file
    with open(start_script_path, 'w') as f:
        # Append shebang line
        append_shebang(f, shell_path)

        # Append sysctl forwarding commands
        append_forwarding(f, ipv6_as_well=has_ipv6)

        # Append comments
        f.write("# Shell script to start nftables configuration for WireGuard\n")

        # Flush existing ruleset
        f.write("nft flush ruleset\n")

        # Load nftables configuration file
        f.write(f"nft -f {str(nftables_conf_path.resolve())}\n")

    # Set file permissions to 700
    start_script_path.chmod(0o700)


def create_stop_script(
    has_ipv6: bool,
    shell_path: Path,
    stop_script_path: Path,
) -> None:
    """
    Generate stop script based on current database config.
    """
    if not stop_script_path.parent.exists():
        raise RuntimeError(
            f"Configuration folder {stop_script_path.parent}"
            f" for {stop_script_path} does not exist."
        )
    print(f"Generating nftables stop script at {stop_script_path}...")

    # Write nftables stop configuration file
    with open(stop_script_path, 'w') as f:
        # Append shebang line
        append_shebang(f, shell_path)

        # Append comments
        f.write("# Shell script to stop nftables configuration for WireGuard\n")

        # Disable IP forwarding
        append_disable_forwarding(f, ipv6_as_well=has_ipv6)

        # Delete nftables tables created for WireGuard
        f.write("nft delete table ip wg_nat || true\n")
        if has_ipv6:
            f.write("nft delete table ip6 wg_nat || true\n")

    # Set file permissions to 700
    stop_script_path.chmod(0o700)


def create_nftables_config(
    wg_config: ServerWGConfig,
    server_config: ServerIFConfig,
    peer_configs: list[PeerConfig],
    nftables_conf_path: Path,
) -> None:
    """
    Generate nftables configuration file based on current database config.
    """

    print(f"Generating nftables configuration file at {nftables_conf_path}...")

    # Write nftables configuration file
    with open(nftables_conf_path, 'w') as f:
        f.write('# nftables configuration generated by wg_gaming_installer\n')
        f.write(
            '# This file defines NAT tables for IPv4 and IPv6 (when configured).\n\n'
        )

        # IPv4 NAT table with chains and rules inside chain blocks
        f.write('table ip wg_nat {\n')

        # SNAT masquerade rule
        f.write(
            '    chain postrouting { type nat hook postrouting priority srcnat; '
            'policy accept;\n'
        )
        f.write(
            f'        iifname "{wg_config.wg_name}" oifname '
            f'"{server_config.nic_name}" masquerade;\n'
        )
        f.write('    }\n')

        # DNAT prerouting chain
        f.write(
            '    chain prerouting { type nat hook prerouting priority dstnat; '
            'policy accept;\n'
        )
        for peer in peer_configs:
            if peer.forward_ports:
                ports_str = peer.forward_ports_str
                f.write(
                    f'        iifname "{server_config.nic_name}" tcp dport '
                    f'{{{ports_str}}} dnat to {peer.ipv4.ip};\n'
                )
                f.write(
                    f'        iifname "{server_config.nic_name}" udp dport '
                    f'{{{ports_str}}} dnat to {peer.ipv4.ip};\n'
                )
        f.write('    }\n')
        f.write('}\n\n')

        # IPv6 NAT table (if configured)
        if wg_config.ipv6:
            f.write('table ip6 wg_nat {\n')

            # IPv6 SNAT masquerade rule
            f.write(
                '    chain postrouting { type nat hook postrouting priority srcnat; '
                'policy accept;\n'
            )
            f.write(
                f'        iifname "{wg_config.wg_name}" oifname '
                f'"{server_config.nic_name}" masquerade;\n'
            )
            f.write('    }\n')

            # IPv6 DNAT prerouting chain
            f.write(
                '    chain prerouting { type nat hook prerouting priority dstnat; '
                'policy accept;\n'
            )
            for peer in peer_configs:
                if peer.ipv6 and peer.forward_ports:
                    ports_str = peer.forward_ports_str
                    f.write(
                        f'        iifname "{server_config.nic_name}" tcp dport '
                        f'{{{ports_str}}} dnat to {peer.ipv6.ip};\n'
                    )
                    f.write(
                        f'        iifname "{server_config.nic_name}" udp dport '
                        f'{{{ports_str}}} dnat to {peer.ipv6.ip};\n'
                    )
            f.write('    }\n')
            f.write('}\n')

    # Set file permissions to 600
    nftables_conf_path.chmod(0o600)


def append_shebang(file: TextIO, shell_path: Path) -> None:
    """
    Append shebang to the start of the script file.
    """
    file.write("#!" + str(shell_path.resolve()) + "\n\n")


def append_forwarding(file: TextIO, ipv6_as_well: bool) -> None:
    """
    Append sysctl command to enable IPv4 forwarding.
    """
    file.write("# Enable IPv4 forwarding\n")
    file.write("sysctl -w net.ipv4.ip_forward=1\n\n")
    if ipv6_as_well:
        file.write("# Enable IPv6 forwarding\n")
        file.write("sysctl -w net.ipv6.conf.all.forwarding=1\n\n")


def append_disable_forwarding(file: TextIO, ipv6_as_well: bool) -> None:
    """
    Append sysctl command to disable IPv4 forwarding.
    """
    file.write("# Disable IPv4 forwarding\n")
    file.write("sysctl -w net.ipv4.ip_forward=0\n\n")
    if ipv6_as_well:
        file.write("# Disable IPv6 forwarding\n")
        file.write("sysctl -w net.ipv6.conf.all.forwarding=0\n\n")

    # Reload sysctl settings
    file.write("sysctl --system\n")
